#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "graphics.h"

#define BLOCK_WIDTH    20
#define MAZE_WIDTH     11                       /* Odd numbers only */
#define MAZE_HEIGHT    11                       /* Odd numbers only */

#define NORTH          0
#define EAST           1
#define SOUTH          2
#define WEST           3

char maze[MAZE_WIDTH][MAZE_HEIGHT];
int bot_dir = EAST;
int bot_x, bot_y;

void generate_maze_random() {
    size_t i, j;
    for (j = 0; j < MAZE_HEIGHT; j += 2) {
        for (i = 0; i < MAZE_WIDTH; i++) {
            maze[i][j] = '1';
        }
    }
    for (j = 1; j < MAZE_HEIGHT; j += 2) {
        for (i = 0; i < MAZE_WIDTH; i += 2) {
            maze[i][j] = '1';
            maze[i+1][j] = '0';
        }
        maze[MAZE_WIDTH-1][j] = '1';
    }
    maze[0][1] = '3';
    maze[MAZE_WIDTH - 1][MAZE_HEIGHT - 2] = '2';

    /* Empty maze generated by this point */

    int visited[MAZE_WIDTH][MAZE_HEIGHT];

    for (j = 0; j < MAZE_HEIGHT; j++) {
        for (i = 0; i < MAZE_WIDTH; i++) {
            visited[i][j] = maze[i][j] - '0';
        }
    }

    srand(time(NULL));
    int randint;
    int num_visited = 1;
    visited[1][1] = 1;

    /* Connect every non-visited cell to a neighbour visited cell */
    while (num_visited < (MAZE_WIDTH / 2) * (MAZE_HEIGHT / 2)) {
        for (j = 1; j < MAZE_HEIGHT; j += 2) {
            for (i = 1; i < MAZE_WIDTH; i += 2) {
                if (visited[i][j] == 0) {
                    randint = rand() % 4;
                    if (randint == 0 && j > 1 && visited[i][j - 2] == 1) {
                        maze[i][j - 1] = '0';
                        visited[i][j] = 1;
                        num_visited++;
                    } else if (randint == 1 && i < MAZE_WIDTH - 2 && visited[i + 2][j] == 1) {
                        maze[i + 1][j] = '0';
                        visited[i][j] = 1;
                        num_visited++;
                    } else if (randint == 2 && j < MAZE_HEIGHT - 2 && visited[i][j + 2] == 1) {
                        maze[i][j + 1] = '0';
                        visited[i][j] = 1;
                        num_visited++;
                    } else if (randint == 3 && i > 1 && visited[i - 2][j] == 1) {
                        maze[i-1][j] = '0';
                        visited[i][j] = 1;
                        num_visited++;
                    }
                }
            }
        }
    }

}

void draw_maze() {
    setWindowSize(BLOCK_WIDTH * MAZE_WIDTH + 2 * BLOCK_WIDTH, BLOCK_WIDTH * MAZE_HEIGHT + 2 * BLOCK_WIDTH);
    background();
    int x, y;
    for (size_t j = 0; j < MAZE_HEIGHT; j++) {
        for (size_t i = 0; i < MAZE_WIDTH; i++) {
            x = BLOCK_WIDTH * (i + 1);
            y = BLOCK_WIDTH * (j + 1);
            if (maze[i][j] == '0' || maze[i][j] == '3') {
                setColour(black);
                drawRect(x, y, BLOCK_WIDTH, BLOCK_WIDTH);
            } else if (maze[i][j] == '1') {
                setColour(black);
                fillRect(x, y, BLOCK_WIDTH, BLOCK_WIDTH);
            } else if (maze[i][j] == '2') {
                setColour(gray);
                fillRect(x, y, BLOCK_WIDTH, BLOCK_WIDTH);
            }
        }
    }
}

void load_random_maze() {
    generate_maze_random();
    draw_maze();
}

void load_maze_from_file() {
    FILE *fp;
    char ch;
    fp = fopen("maze_structure.txt", "r");

    size_t counter = 0;
    size_t width = 0, height = 0;
    int x, y;
    setWindowSize(BLOCK_WIDTH * MAZE_WIDTH + 2 * BLOCK_WIDTH, BLOCK_WIDTH * MAZE_HEIGHT + 2 * BLOCK_WIDTH);
    background();
    do {
        ch = getc(fp);
        if (ch != '0' && ch != '1' && ch != '2') continue;

        x = BLOCK_WIDTH * (counter % MAZE_WIDTH) + BLOCK_WIDTH;
        y = BLOCK_WIDTH * (counter / MAZE_WIDTH) + BLOCK_WIDTH;
        if (ch == '0') {
            setColour(black);
            drawRect(x, y, BLOCK_WIDTH, BLOCK_WIDTH);
        } else if (ch == '1') {
            setColour(black);
            fillRect(x, y, BLOCK_WIDTH, BLOCK_WIDTH);
        } else if (ch == '2') {
            setColour(gray);
            fillRect(x, y, BLOCK_WIDTH, BLOCK_WIDTH);
        }

        maze[counter % MAZE_WIDTH][counter / MAZE_WIDTH] = ch;
        counter++;
    } while (ch != EOF);
    
    fclose(fp);
}

void get_robot_pos(int direction, int *x_pos, int *y_pos, int x, int y) {
    if (direction == NORTH) {
        x_pos[0] = x;
        x_pos[1] = x + BLOCK_WIDTH;
        x_pos[2] = x + BLOCK_WIDTH / 2;
        y_pos[0] = y + BLOCK_WIDTH;
        y_pos[1] = y + BLOCK_WIDTH;
        y_pos[2] = y;
    } else if (direction == EAST) {
        x_pos[0] = x;
        x_pos[1] = x;
        x_pos[2] = x + BLOCK_WIDTH;
        y_pos[0] = y;
        y_pos[1] = y + BLOCK_WIDTH;
        y_pos[2] = y + BLOCK_WIDTH / 2;
    } else if (direction == SOUTH) {
        x_pos[0] = x + BLOCK_WIDTH;
        x_pos[1] = x;
        x_pos[2] = x + BLOCK_WIDTH / 2;
        y_pos[0] = y;
        y_pos[1] = y;
        y_pos[2] = y + BLOCK_WIDTH;
    } else if (direction == WEST) {
        x_pos[0] = x + BLOCK_WIDTH;
        x_pos[1] = x + BLOCK_WIDTH;
        x_pos[2] = x;
        y_pos[0] = y + BLOCK_WIDTH;
        y_pos[1] = y;
        y_pos[2] = y + BLOCK_WIDTH / 2;
    }
}

void draw_robot() {
    foreground();
    clear();
    setColour(green);
    int x_pos[3], y_pos[3];
    get_robot_pos(bot_dir, x_pos, y_pos, bot_x, bot_y);
    fillPolygon(3, x_pos, y_pos);
    sleep(50);
}

void move_forward() {
    if (bot_dir == NORTH) {
        bot_y -= BLOCK_WIDTH;
    } else if (bot_dir == EAST) {
        bot_x += BLOCK_WIDTH;
    } else if (bot_dir == SOUTH) {
        bot_y += BLOCK_WIDTH;
    } else if (bot_dir == WEST) {
        bot_x -= BLOCK_WIDTH;
    }
    draw_robot();
}

int can_forward() {
    int x = bot_x, y = bot_y;
    if (bot_dir == NORTH) {
        y -= BLOCK_WIDTH;
    } else if (bot_dir == EAST) {
        x += BLOCK_WIDTH;
    } else if (bot_dir == SOUTH) {
        y += BLOCK_WIDTH;
    } else if (bot_dir == WEST) {
        x -= BLOCK_WIDTH;
    }
    return maze[x / BLOCK_WIDTH - 1][y / BLOCK_WIDTH - 1] != '1';
}

int can_right() {
    int x = bot_x, y = bot_y;
    if (bot_dir == NORTH) {
        x += BLOCK_WIDTH;
    } else if (bot_dir == EAST) {
        y += BLOCK_WIDTH;
    } else if (bot_dir == SOUTH) {
        x -= BLOCK_WIDTH;
    } else if (bot_dir == WEST) {
        y -= BLOCK_WIDTH;
    }
    return maze[x / BLOCK_WIDTH - 1][y / BLOCK_WIDTH - 1] != '1';
}

int can_left() {
    int x = bot_x, y = bot_y;
    if (bot_dir == NORTH) {
        x -= BLOCK_WIDTH;
    } else if (bot_dir == EAST) {
        y -= BLOCK_WIDTH;
    } else if (bot_dir == SOUTH) {
        x += BLOCK_WIDTH;
    } else if (bot_dir == WEST) {
        y += BLOCK_WIDTH;
    }
    return maze[x / BLOCK_WIDTH - 1][y / BLOCK_WIDTH - 1] != '1';
}

int at_exit() {
    return maze[bot_x / BLOCK_WIDTH - 1][bot_y / BLOCK_WIDTH - 1] == '2';
}

void turn_left() {
    bot_dir = (bot_dir + 3) % 4;
    draw_robot();
}

void turn_right() {
    bot_dir = (bot_dir + 1) % 4;
    draw_robot();
}

void initialize() {
    draw_maze();
    bot_x = BLOCK_WIDTH;
    bot_y = BLOCK_WIDTH * 2;
    draw_robot();
}

void left_wall_follower() {
    while (!at_exit()) {
        if (can_left()) {
            turn_left();
            move_forward();
        } else if (can_forward()) {
            move_forward();
        } else {
            turn_right();
        }
    }
}

void right_wall_follower() {
    while (!at_exit()) {
        if (can_right()) {
            turn_right();
            move_forward();
        } else if (can_forward()) {
            move_forward();
        } else {
            turn_left();
        }
    }
}

int main(void) {
    load_maze_from_file();
    // load_random_maze();
    
    initialize();

    left_wall_follower();
    // right_wall_follower();
}
